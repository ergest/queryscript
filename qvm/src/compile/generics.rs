use snafu::prelude::*;
use std::any::Any;
use std::collections::BTreeMap;
use std::sync::Arc;

use super::{
    error::*, inference::mkcref, inference::Constrainable, schema::*, sql::get_rowtype, Compiler,
};
use crate::ast::SourceLocation;
use crate::types::{AtomicType, Type};

pub fn as_generic<T: Generic + 'static>(g: &dyn Generic) -> Option<&T> {
    g.as_any().downcast_ref::<T>()
}

fn debug_fmt_generic(
    f: &mut std::fmt::Formatter<'_>,
    name: &str,
    arg: &CRef<MType>,
) -> std::fmt::Result {
    write!(f, "{}<", name)?;
    std::fmt::Debug::fmt(arg, f)?;
    write!(f, ">")
}

pub struct SumGeneric(CRef<MType>);

fn validate_args(
    loc: &SourceLocation,
    args: &Vec<CRef<MType>>,
    num: usize,
    name: &str,
) -> Result<()> {
    if args.len() != num {
        return Err(CompileError::internal(
            loc.clone(),
            format!("{} expects {} argument", name, num).as_str(),
        ));
    }
    Ok(())
}

// TODO: Some of this boilerplate can be generated by a macro. We may need to create an implementation
// per tuple length...

impl SumGeneric {
    const NAME: &str = "SumAgg";

    pub fn new(loc: &SourceLocation, mut args: Vec<CRef<MType>>) -> Result<Arc<dyn Generic>> {
        validate_args(loc, &args, 1, Self::NAME)?;
        Ok(Arc::new(SumGeneric(args.swap_remove(0))))
    }
}

impl std::fmt::Debug for SumGeneric {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        debug_fmt_generic(f, Self::NAME, &self.0)
    }
}

impl Generic for SumGeneric {
    fn as_any(&self) -> &dyn Any {
        self
    }

    fn name(&self) -> &str {
        Self::NAME
    }

    fn to_runtime_type(&self) -> crate::runtime::error::Result<crate::types::Type> {
        let arg = self.0.must()?.read()?.to_runtime_type()?;

        // DuckDB's sum function follows the following rules:
        // 	sum(DECIMAL) -> DECIMAL
        //	sum(SMALLINT) -> HUGEINT
        //	sum(INTEGER) -> HUGEINT
        //	sum(BIGINT) -> HUGEINT
        //	sum(HUGEINT) -> HUGEINT
        //	sum(DOUBLE) -> DOUBLE
        match &arg {
            Type::Atom(at) => Ok(Type::Atom(match &at {
                AtomicType::Int8
                | AtomicType::Int16
                | AtomicType::Int32
                | AtomicType::Int64
                | AtomicType::UInt8
                | AtomicType::UInt16
                | AtomicType::UInt32
                | AtomicType::UInt64 => AtomicType::Decimal128(38, 0),
                AtomicType::Float32 | AtomicType::Float64 => AtomicType::Float64,
                AtomicType::Decimal128(..) | AtomicType::Decimal256(..) => at.clone(),
                _ => {
                    return Err(crate::runtime::error::RuntimeError::new(
                        format!(
                            "sum(): expected argument to be a numeric ype, got {:?}",
                            arg
                        )
                        .as_str(),
                    ))
                }
            })),
            _ => {
                return Err(crate::runtime::error::RuntimeError::new(
                    format!(
                        "sum(): expected argument to be an atomic type, got {:?}",
                        arg
                    )
                    .as_str(),
                ))
            }
        }
    }

    fn substitute(&self, variables: &BTreeMap<String, CRef<MType>>) -> Result<Arc<dyn Generic>> {
        Ok(Arc::new(Self(self.0.substitute(variables)?)))
    }

    fn unify(&self, other: &MType) -> Result<()> {
        // This is a bit of an approximate implementation, since it only works if the inner
        // type is known.
        if self.0.is_known()? {
            let final_type =
                MType::from_runtime_type(&self.to_runtime_type().context(RuntimeSnafu {
                    loc: ErrorLocation::Unknown,
                })?)?;
            other.unify(&final_type)?;
        }
        Ok(())
    }
}

pub struct ExternalType(CRef<MType>);

impl ExternalType {
    const NAME: &str = "External";

    pub fn new(loc: &SourceLocation, mut args: Vec<CRef<MType>>) -> Result<Arc<dyn Generic>> {
        validate_args(loc, &args, 1, Self::NAME)?;
        Ok(Arc::new(ExternalType(args.swap_remove(0))))
    }

    pub fn inner_type(&self) -> CRef<MType> {
        self.0.clone()
    }
}

impl std::fmt::Debug for ExternalType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        debug_fmt_generic(f, Self::NAME, &self.0)
    }
}

impl Generic for ExternalType {
    fn as_any(&self) -> &dyn Any {
        self
    }

    fn name(&self) -> &str {
        Self::NAME
    }

    fn to_runtime_type(&self) -> crate::runtime::error::Result<crate::types::Type> {
        self.0.must()?.read()?.to_runtime_type()
    }

    fn substitute(&self, variables: &BTreeMap<String, CRef<MType>>) -> Result<Arc<dyn Generic>> {
        Ok(Arc::new(Self(self.0.substitute(variables)?)))
    }

    fn unify(&self, other: &MType) -> Result<()> {
        let inner_type = &self.0;

        match other {
            MType::Generic(other_inner) => {
                if let Some(other) = as_generic::<Self>(other_inner.as_ref()) {
                    inner_type.unify(&other.0)?;
                } else {
                    inner_type.unify(&mkcref(other.clone()))?;
                }
            }
            other => {
                inner_type.unify(&mkcref(other.clone()))?;
            }
        };
        Ok(())
    }

    fn get_rowtype(&self, compiler: Compiler) -> Result<Option<CRef<MType>>> {
        Ok(Some(get_rowtype(compiler, self.0.clone())?))
    }
}
